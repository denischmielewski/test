// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RCFProtoServices.proto

#ifndef PROTOBUF_RCFProtoServices_2eproto__INCLUDED
#define PROTOBUF_RCFProtoServices_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_RCFProtoServices_2eproto();
void protobuf_AssignDesc_RCFProtoServices_2eproto();
void protobuf_ShutdownFile_RCFProtoServices_2eproto();

class PositionInformationTransmit;
class PositionInformationReceive;
class SetOperationModeCommand;
class SetOperationModeResponse;
class traindata;
class MapTrainData;
class GetFleetCommand;
class GetFleetResponse;

// ===================================================================

class PositionInformationTransmit : public ::google::protobuf::Message {
 public:
  PositionInformationTransmit();
  virtual ~PositionInformationTransmit();

  PositionInformationTransmit(const PositionInformationTransmit& from);

  inline PositionInformationTransmit& operator=(const PositionInformationTransmit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionInformationTransmit& default_instance();

  void Swap(PositionInformationTransmit* other);

  // implements Message ----------------------------------------------

  PositionInformationTransmit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionInformationTransmit& from);
  void MergeFrom(const PositionInformationTransmit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trainid = 1;
  inline bool has_trainid() const;
  inline void clear_trainid();
  static const int kTrainidFieldNumber = 1;
  inline const ::std::string& trainid() const;
  inline void set_trainid(const ::std::string& value);
  inline void set_trainid(const char* value);
  inline void set_trainid(const char* value, size_t size);
  inline ::std::string* mutable_trainid();
  inline ::std::string* release_trainid();
  inline void set_allocated_trainid(::std::string* trainid);

  // optional float kpPosition = 2;
  inline bool has_kpposition() const;
  inline void clear_kpposition();
  static const int kKpPositionFieldNumber = 2;
  inline float kpposition() const;
  inline void set_kpposition(float value);

  // optional int32 mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 movement = 4;
  inline bool has_movement() const;
  inline void clear_movement();
  static const int kMovementFieldNumber = 4;
  inline ::google::protobuf::int32 movement() const;
  inline void set_movement(::google::protobuf::int32 value);

  // optional int32 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional string path = 6;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 6;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:PositionInformationTransmit)
 private:
  inline void set_has_trainid();
  inline void clear_has_trainid();
  inline void set_has_kpposition();
  inline void clear_has_kpposition();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_movement();
  inline void clear_has_movement();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* trainid_;
  float kpposition_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 movement_;
  ::google::protobuf::int32 direction_;
  ::std::string* path_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static PositionInformationTransmit* default_instance_;
};
// -------------------------------------------------------------------

class PositionInformationReceive : public ::google::protobuf::Message {
 public:
  PositionInformationReceive();
  virtual ~PositionInformationReceive();

  PositionInformationReceive(const PositionInformationReceive& from);

  inline PositionInformationReceive& operator=(const PositionInformationReceive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionInformationReceive& default_instance();

  void Swap(PositionInformationReceive* other);

  // implements Message ----------------------------------------------

  PositionInformationReceive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionInformationReceive& from);
  void MergeFrom(const PositionInformationReceive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string servername = 1;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 1;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // @@protoc_insertion_point(class_scope:PositionInformationReceive)
 private:
  inline void set_has_servername();
  inline void clear_has_servername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* servername_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static PositionInformationReceive* default_instance_;
};
// -------------------------------------------------------------------

class SetOperationModeCommand : public ::google::protobuf::Message {
 public:
  SetOperationModeCommand();
  virtual ~SetOperationModeCommand();

  SetOperationModeCommand(const SetOperationModeCommand& from);

  inline SetOperationModeCommand& operator=(const SetOperationModeCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetOperationModeCommand& default_instance();

  void Swap(SetOperationModeCommand* other);

  // implements Message ----------------------------------------------

  SetOperationModeCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetOperationModeCommand& from);
  void MergeFrom(const SetOperationModeCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline const ::std::string& mode() const;
  inline void set_mode(const ::std::string& value);
  inline void set_mode(const char* value);
  inline void set_mode(const char* value, size_t size);
  inline ::std::string* mutable_mode();
  inline ::std::string* release_mode();
  inline void set_allocated_mode(::std::string* mode);

  // @@protoc_insertion_point(class_scope:SetOperationModeCommand)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mode_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static SetOperationModeCommand* default_instance_;
};
// -------------------------------------------------------------------

class SetOperationModeResponse : public ::google::protobuf::Message {
 public:
  SetOperationModeResponse();
  virtual ~SetOperationModeResponse();

  SetOperationModeResponse(const SetOperationModeResponse& from);

  inline SetOperationModeResponse& operator=(const SetOperationModeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetOperationModeResponse& default_instance();

  void Swap(SetOperationModeResponse* other);

  // implements Message ----------------------------------------------

  SetOperationModeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetOperationModeResponse& from);
  void MergeFrom(const SetOperationModeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string previousmode = 1;
  inline bool has_previousmode() const;
  inline void clear_previousmode();
  static const int kPreviousmodeFieldNumber = 1;
  inline const ::std::string& previousmode() const;
  inline void set_previousmode(const ::std::string& value);
  inline void set_previousmode(const char* value);
  inline void set_previousmode(const char* value, size_t size);
  inline ::std::string* mutable_previousmode();
  inline ::std::string* release_previousmode();
  inline void set_allocated_previousmode(::std::string* previousmode);

  // required string newmode = 2;
  inline bool has_newmode() const;
  inline void clear_newmode();
  static const int kNewmodeFieldNumber = 2;
  inline const ::std::string& newmode() const;
  inline void set_newmode(const ::std::string& value);
  inline void set_newmode(const char* value);
  inline void set_newmode(const char* value, size_t size);
  inline ::std::string* mutable_newmode();
  inline ::std::string* release_newmode();
  inline void set_allocated_newmode(::std::string* newmode);

  // @@protoc_insertion_point(class_scope:SetOperationModeResponse)
 private:
  inline void set_has_previousmode();
  inline void clear_has_previousmode();
  inline void set_has_newmode();
  inline void clear_has_newmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* previousmode_;
  ::std::string* newmode_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static SetOperationModeResponse* default_instance_;
};
// -------------------------------------------------------------------

class traindata : public ::google::protobuf::Message {
 public:
  traindata();
  virtual ~traindata();

  traindata(const traindata& from);

  inline traindata& operator=(const traindata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const traindata& default_instance();

  void Swap(traindata* other);

  // implements Message ----------------------------------------------

  traindata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const traindata& from);
  void MergeFrom(const traindata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float kpPosition = 1;
  inline bool has_kpposition() const;
  inline void clear_kpposition();
  static const int kKpPositionFieldNumber = 1;
  inline float kpposition() const;
  inline void set_kpposition(float value);

  // optional int32 mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional int32 movement = 3;
  inline bool has_movement() const;
  inline void clear_movement();
  static const int kMovementFieldNumber = 3;
  inline ::google::protobuf::int32 movement() const;
  inline void set_movement(::google::protobuf::int32 value);

  // optional int32 direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional string path = 5;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 5;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:traindata)
 private:
  inline void set_has_kpposition();
  inline void clear_has_kpposition();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_movement();
  inline void clear_has_movement();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float kpposition_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 movement_;
  ::google::protobuf::int32 direction_;
  ::std::string* path_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static traindata* default_instance_;
};
// -------------------------------------------------------------------

class MapTrainData : public ::google::protobuf::Message {
 public:
  MapTrainData();
  virtual ~MapTrainData();

  MapTrainData(const MapTrainData& from);

  inline MapTrainData& operator=(const MapTrainData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapTrainData& default_instance();

  void Swap(MapTrainData* other);

  // implements Message ----------------------------------------------

  MapTrainData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapTrainData& from);
  void MergeFrom(const MapTrainData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ipaddress = 1;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional .traindata traindata = 2;
  inline bool has_traindata() const;
  inline void clear_traindata();
  static const int kTraindataFieldNumber = 2;
  inline const ::traindata& traindata() const;
  inline ::traindata* mutable_traindata();
  inline ::traindata* release_traindata();
  inline void set_allocated_traindata(::traindata* traindata);

  // @@protoc_insertion_point(class_scope:MapTrainData)
 private:
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_traindata();
  inline void clear_has_traindata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ipaddress_;
  ::traindata* traindata_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static MapTrainData* default_instance_;
};
// -------------------------------------------------------------------

class GetFleetCommand : public ::google::protobuf::Message {
 public:
  GetFleetCommand();
  virtual ~GetFleetCommand();

  GetFleetCommand(const GetFleetCommand& from);

  inline GetFleetCommand& operator=(const GetFleetCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFleetCommand& default_instance();

  void Swap(GetFleetCommand* other);

  // implements Message ----------------------------------------------

  GetFleetCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFleetCommand& from);
  void MergeFrom(const GetFleetCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ipaddress = 1;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // @@protoc_insertion_point(class_scope:GetFleetCommand)
 private:
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ipaddress_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static GetFleetCommand* default_instance_;
};
// -------------------------------------------------------------------

class GetFleetResponse : public ::google::protobuf::Message {
 public:
  GetFleetResponse();
  virtual ~GetFleetResponse();

  GetFleetResponse(const GetFleetResponse& from);

  inline GetFleetResponse& operator=(const GetFleetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFleetResponse& default_instance();

  void Swap(GetFleetResponse* other);

  // implements Message ----------------------------------------------

  GetFleetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetFleetResponse& from);
  void MergeFrom(const GetFleetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapTrainData traindata = 1;
  inline int traindata_size() const;
  inline void clear_traindata();
  static const int kTraindataFieldNumber = 1;
  inline const ::MapTrainData& traindata(int index) const;
  inline ::MapTrainData* mutable_traindata(int index);
  inline ::MapTrainData* add_traindata();
  inline const ::google::protobuf::RepeatedPtrField< ::MapTrainData >&
      traindata() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapTrainData >*
      mutable_traindata();

  // @@protoc_insertion_point(class_scope:GetFleetResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MapTrainData > traindata_;
  friend void  protobuf_AddDesc_RCFProtoServices_2eproto();
  friend void protobuf_AssignDesc_RCFProtoServices_2eproto();
  friend void protobuf_ShutdownFile_RCFProtoServices_2eproto();

  void InitAsDefaultInstance();
  static GetFleetResponse* default_instance_;
};
// ===================================================================

class PositionInformationService_Stub;

class PositionInformationService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline PositionInformationService() {};
 public:
  virtual ~PositionInformationService();

  typedef PositionInformationService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void PositionInformation(::google::protobuf::RpcController* controller,
                       const ::PositionInformationTransmit* request,
                       ::PositionInformationReceive* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(PositionInformationService);
};

class PositionInformationService_Stub : public PositionInformationService {
 public:
  PositionInformationService_Stub(::google::protobuf::RpcChannel* channel);
  PositionInformationService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~PositionInformationService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements PositionInformationService ------------------------------------------

  void PositionInformation(::google::protobuf::RpcController* controller,
                       const ::PositionInformationTransmit* request,
                       ::PositionInformationReceive* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(PositionInformationService_Stub);
};


// -------------------------------------------------------------------

class SetOperationModeService_Stub;

class SetOperationModeService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SetOperationModeService() {};
 public:
  virtual ~SetOperationModeService();

  typedef SetOperationModeService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void SetOperationMode(::google::protobuf::RpcController* controller,
                       const ::SetOperationModeCommand* request,
                       ::SetOperationModeResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SetOperationModeService);
};

class SetOperationModeService_Stub : public SetOperationModeService {
 public:
  SetOperationModeService_Stub(::google::protobuf::RpcChannel* channel);
  SetOperationModeService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SetOperationModeService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements SetOperationModeService ------------------------------------------

  void SetOperationMode(::google::protobuf::RpcController* controller,
                       const ::SetOperationModeCommand* request,
                       ::SetOperationModeResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SetOperationModeService_Stub);
};


// -------------------------------------------------------------------

class GetFleetService_Stub;

class GetFleetService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline GetFleetService() {};
 public:
  virtual ~GetFleetService();

  typedef GetFleetService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void GetFleet(::google::protobuf::RpcController* controller,
                       const ::GetFleetCommand* request,
                       ::GetFleetResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GetFleetService);
};

class GetFleetService_Stub : public GetFleetService {
 public:
  GetFleetService_Stub(::google::protobuf::RpcChannel* channel);
  GetFleetService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~GetFleetService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements GetFleetService ------------------------------------------

  void GetFleet(::google::protobuf::RpcController* controller,
                       const ::GetFleetCommand* request,
                       ::GetFleetResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GetFleetService_Stub);
};


// ===================================================================


// ===================================================================

// PositionInformationTransmit

// optional string trainid = 1;
inline bool PositionInformationTransmit::has_trainid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionInformationTransmit::set_has_trainid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionInformationTransmit::clear_has_trainid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionInformationTransmit::clear_trainid() {
  if (trainid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trainid_->clear();
  }
  clear_has_trainid();
}
inline const ::std::string& PositionInformationTransmit::trainid() const {
  // @@protoc_insertion_point(field_get:PositionInformationTransmit.trainid)
  return *trainid_;
}
inline void PositionInformationTransmit::set_trainid(const ::std::string& value) {
  set_has_trainid();
  if (trainid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trainid_ = new ::std::string;
  }
  trainid_->assign(value);
  // @@protoc_insertion_point(field_set:PositionInformationTransmit.trainid)
}
inline void PositionInformationTransmit::set_trainid(const char* value) {
  set_has_trainid();
  if (trainid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trainid_ = new ::std::string;
  }
  trainid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PositionInformationTransmit.trainid)
}
inline void PositionInformationTransmit::set_trainid(const char* value, size_t size) {
  set_has_trainid();
  if (trainid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trainid_ = new ::std::string;
  }
  trainid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PositionInformationTransmit.trainid)
}
inline ::std::string* PositionInformationTransmit::mutable_trainid() {
  set_has_trainid();
  if (trainid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trainid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PositionInformationTransmit.trainid)
  return trainid_;
}
inline ::std::string* PositionInformationTransmit::release_trainid() {
  clear_has_trainid();
  if (trainid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = trainid_;
    trainid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionInformationTransmit::set_allocated_trainid(::std::string* trainid) {
  if (trainid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trainid_;
  }
  if (trainid) {
    set_has_trainid();
    trainid_ = trainid;
  } else {
    clear_has_trainid();
    trainid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PositionInformationTransmit.trainid)
}

// optional float kpPosition = 2;
inline bool PositionInformationTransmit::has_kpposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionInformationTransmit::set_has_kpposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionInformationTransmit::clear_has_kpposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionInformationTransmit::clear_kpposition() {
  kpposition_ = 0;
  clear_has_kpposition();
}
inline float PositionInformationTransmit::kpposition() const {
  // @@protoc_insertion_point(field_get:PositionInformationTransmit.kpPosition)
  return kpposition_;
}
inline void PositionInformationTransmit::set_kpposition(float value) {
  set_has_kpposition();
  kpposition_ = value;
  // @@protoc_insertion_point(field_set:PositionInformationTransmit.kpPosition)
}

// optional int32 mode = 3;
inline bool PositionInformationTransmit::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionInformationTransmit::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionInformationTransmit::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionInformationTransmit::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 PositionInformationTransmit::mode() const {
  // @@protoc_insertion_point(field_get:PositionInformationTransmit.mode)
  return mode_;
}
inline void PositionInformationTransmit::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:PositionInformationTransmit.mode)
}

// optional int32 movement = 4;
inline bool PositionInformationTransmit::has_movement() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionInformationTransmit::set_has_movement() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionInformationTransmit::clear_has_movement() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionInformationTransmit::clear_movement() {
  movement_ = 0;
  clear_has_movement();
}
inline ::google::protobuf::int32 PositionInformationTransmit::movement() const {
  // @@protoc_insertion_point(field_get:PositionInformationTransmit.movement)
  return movement_;
}
inline void PositionInformationTransmit::set_movement(::google::protobuf::int32 value) {
  set_has_movement();
  movement_ = value;
  // @@protoc_insertion_point(field_set:PositionInformationTransmit.movement)
}

// optional int32 direction = 5;
inline bool PositionInformationTransmit::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionInformationTransmit::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionInformationTransmit::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionInformationTransmit::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 PositionInformationTransmit::direction() const {
  // @@protoc_insertion_point(field_get:PositionInformationTransmit.direction)
  return direction_;
}
inline void PositionInformationTransmit::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:PositionInformationTransmit.direction)
}

// optional string path = 6;
inline bool PositionInformationTransmit::has_path() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionInformationTransmit::set_has_path() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionInformationTransmit::clear_has_path() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionInformationTransmit::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& PositionInformationTransmit::path() const {
  // @@protoc_insertion_point(field_get:PositionInformationTransmit.path)
  return *path_;
}
inline void PositionInformationTransmit::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:PositionInformationTransmit.path)
}
inline void PositionInformationTransmit::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:PositionInformationTransmit.path)
}
inline void PositionInformationTransmit::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PositionInformationTransmit.path)
}
inline ::std::string* PositionInformationTransmit::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PositionInformationTransmit.path)
  return path_;
}
inline ::std::string* PositionInformationTransmit::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionInformationTransmit::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PositionInformationTransmit.path)
}

// -------------------------------------------------------------------

// PositionInformationReceive

// optional string servername = 1;
inline bool PositionInformationReceive::has_servername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionInformationReceive::set_has_servername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionInformationReceive::clear_has_servername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionInformationReceive::clear_servername() {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& PositionInformationReceive::servername() const {
  // @@protoc_insertion_point(field_get:PositionInformationReceive.servername)
  return *servername_;
}
inline void PositionInformationReceive::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set:PositionInformationReceive.servername)
}
inline void PositionInformationReceive::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set_char:PositionInformationReceive.servername)
}
inline void PositionInformationReceive::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PositionInformationReceive.servername)
}
inline ::std::string* PositionInformationReceive::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PositionInformationReceive.servername)
  return servername_;
}
inline ::std::string* PositionInformationReceive::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionInformationReceive::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PositionInformationReceive.servername)
}

// -------------------------------------------------------------------

// SetOperationModeCommand

// required string mode = 1;
inline bool SetOperationModeCommand::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetOperationModeCommand::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetOperationModeCommand::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetOperationModeCommand::clear_mode() {
  if (mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_->clear();
  }
  clear_has_mode();
}
inline const ::std::string& SetOperationModeCommand::mode() const {
  // @@protoc_insertion_point(field_get:SetOperationModeCommand.mode)
  return *mode_;
}
inline void SetOperationModeCommand::set_mode(const ::std::string& value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
  // @@protoc_insertion_point(field_set:SetOperationModeCommand.mode)
}
inline void SetOperationModeCommand::set_mode(const char* value) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  mode_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOperationModeCommand.mode)
}
inline void SetOperationModeCommand::set_mode(const char* value, size_t size) {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  mode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOperationModeCommand.mode)
}
inline ::std::string* SetOperationModeCommand::mutable_mode() {
  set_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetOperationModeCommand.mode)
  return mode_;
}
inline ::std::string* SetOperationModeCommand::release_mode() {
  clear_has_mode();
  if (mode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mode_;
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetOperationModeCommand::set_allocated_mode(::std::string* mode) {
  if (mode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mode_;
  }
  if (mode) {
    set_has_mode();
    mode_ = mode;
  } else {
    clear_has_mode();
    mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetOperationModeCommand.mode)
}

// -------------------------------------------------------------------

// SetOperationModeResponse

// required string previousmode = 1;
inline bool SetOperationModeResponse::has_previousmode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetOperationModeResponse::set_has_previousmode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetOperationModeResponse::clear_has_previousmode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetOperationModeResponse::clear_previousmode() {
  if (previousmode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousmode_->clear();
  }
  clear_has_previousmode();
}
inline const ::std::string& SetOperationModeResponse::previousmode() const {
  // @@protoc_insertion_point(field_get:SetOperationModeResponse.previousmode)
  return *previousmode_;
}
inline void SetOperationModeResponse::set_previousmode(const ::std::string& value) {
  set_has_previousmode();
  if (previousmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousmode_ = new ::std::string;
  }
  previousmode_->assign(value);
  // @@protoc_insertion_point(field_set:SetOperationModeResponse.previousmode)
}
inline void SetOperationModeResponse::set_previousmode(const char* value) {
  set_has_previousmode();
  if (previousmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousmode_ = new ::std::string;
  }
  previousmode_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOperationModeResponse.previousmode)
}
inline void SetOperationModeResponse::set_previousmode(const char* value, size_t size) {
  set_has_previousmode();
  if (previousmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousmode_ = new ::std::string;
  }
  previousmode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOperationModeResponse.previousmode)
}
inline ::std::string* SetOperationModeResponse::mutable_previousmode() {
  set_has_previousmode();
  if (previousmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousmode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetOperationModeResponse.previousmode)
  return previousmode_;
}
inline ::std::string* SetOperationModeResponse::release_previousmode() {
  clear_has_previousmode();
  if (previousmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = previousmode_;
    previousmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetOperationModeResponse::set_allocated_previousmode(::std::string* previousmode) {
  if (previousmode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete previousmode_;
  }
  if (previousmode) {
    set_has_previousmode();
    previousmode_ = previousmode;
  } else {
    clear_has_previousmode();
    previousmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetOperationModeResponse.previousmode)
}

// required string newmode = 2;
inline bool SetOperationModeResponse::has_newmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetOperationModeResponse::set_has_newmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetOperationModeResponse::clear_has_newmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetOperationModeResponse::clear_newmode() {
  if (newmode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    newmode_->clear();
  }
  clear_has_newmode();
}
inline const ::std::string& SetOperationModeResponse::newmode() const {
  // @@protoc_insertion_point(field_get:SetOperationModeResponse.newmode)
  return *newmode_;
}
inline void SetOperationModeResponse::set_newmode(const ::std::string& value) {
  set_has_newmode();
  if (newmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    newmode_ = new ::std::string;
  }
  newmode_->assign(value);
  // @@protoc_insertion_point(field_set:SetOperationModeResponse.newmode)
}
inline void SetOperationModeResponse::set_newmode(const char* value) {
  set_has_newmode();
  if (newmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    newmode_ = new ::std::string;
  }
  newmode_->assign(value);
  // @@protoc_insertion_point(field_set_char:SetOperationModeResponse.newmode)
}
inline void SetOperationModeResponse::set_newmode(const char* value, size_t size) {
  set_has_newmode();
  if (newmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    newmode_ = new ::std::string;
  }
  newmode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetOperationModeResponse.newmode)
}
inline ::std::string* SetOperationModeResponse::mutable_newmode() {
  set_has_newmode();
  if (newmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    newmode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SetOperationModeResponse.newmode)
  return newmode_;
}
inline ::std::string* SetOperationModeResponse::release_newmode() {
  clear_has_newmode();
  if (newmode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = newmode_;
    newmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetOperationModeResponse::set_allocated_newmode(::std::string* newmode) {
  if (newmode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete newmode_;
  }
  if (newmode) {
    set_has_newmode();
    newmode_ = newmode;
  } else {
    clear_has_newmode();
    newmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SetOperationModeResponse.newmode)
}

// -------------------------------------------------------------------

// traindata

// optional float kpPosition = 1;
inline bool traindata::has_kpposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void traindata::set_has_kpposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void traindata::clear_has_kpposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void traindata::clear_kpposition() {
  kpposition_ = 0;
  clear_has_kpposition();
}
inline float traindata::kpposition() const {
  // @@protoc_insertion_point(field_get:traindata.kpPosition)
  return kpposition_;
}
inline void traindata::set_kpposition(float value) {
  set_has_kpposition();
  kpposition_ = value;
  // @@protoc_insertion_point(field_set:traindata.kpPosition)
}

// optional int32 mode = 2;
inline bool traindata::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void traindata::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void traindata::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void traindata::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 traindata::mode() const {
  // @@protoc_insertion_point(field_get:traindata.mode)
  return mode_;
}
inline void traindata::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:traindata.mode)
}

// optional int32 movement = 3;
inline bool traindata::has_movement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void traindata::set_has_movement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void traindata::clear_has_movement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void traindata::clear_movement() {
  movement_ = 0;
  clear_has_movement();
}
inline ::google::protobuf::int32 traindata::movement() const {
  // @@protoc_insertion_point(field_get:traindata.movement)
  return movement_;
}
inline void traindata::set_movement(::google::protobuf::int32 value) {
  set_has_movement();
  movement_ = value;
  // @@protoc_insertion_point(field_set:traindata.movement)
}

// optional int32 direction = 4;
inline bool traindata::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void traindata::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void traindata::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void traindata::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 traindata::direction() const {
  // @@protoc_insertion_point(field_get:traindata.direction)
  return direction_;
}
inline void traindata::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:traindata.direction)
}

// optional string path = 5;
inline bool traindata::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void traindata::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void traindata::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void traindata::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& traindata::path() const {
  // @@protoc_insertion_point(field_get:traindata.path)
  return *path_;
}
inline void traindata::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:traindata.path)
}
inline void traindata::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:traindata.path)
}
inline void traindata::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:traindata.path)
}
inline ::std::string* traindata::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:traindata.path)
  return path_;
}
inline ::std::string* traindata::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void traindata::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:traindata.path)
}

// -------------------------------------------------------------------

// MapTrainData

// required string ipaddress = 1;
inline bool MapTrainData::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapTrainData::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapTrainData::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapTrainData::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& MapTrainData::ipaddress() const {
  // @@protoc_insertion_point(field_get:MapTrainData.ipaddress)
  return *ipaddress_;
}
inline void MapTrainData::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
  // @@protoc_insertion_point(field_set:MapTrainData.ipaddress)
}
inline void MapTrainData::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:MapTrainData.ipaddress)
}
inline void MapTrainData::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapTrainData.ipaddress)
}
inline ::std::string* MapTrainData::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MapTrainData.ipaddress)
  return ipaddress_;
}
inline ::std::string* MapTrainData::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MapTrainData::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MapTrainData.ipaddress)
}

// optional .traindata traindata = 2;
inline bool MapTrainData::has_traindata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapTrainData::set_has_traindata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapTrainData::clear_has_traindata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapTrainData::clear_traindata() {
  if (traindata_ != NULL) traindata_->::traindata::Clear();
  clear_has_traindata();
}
inline const ::traindata& MapTrainData::traindata() const {
  // @@protoc_insertion_point(field_get:MapTrainData.traindata)
  return traindata_ != NULL ? *traindata_ : *default_instance_->traindata_;
}
inline ::traindata* MapTrainData::mutable_traindata() {
  set_has_traindata();
  if (traindata_ == NULL) traindata_ = new ::traindata;
  // @@protoc_insertion_point(field_mutable:MapTrainData.traindata)
  return traindata_;
}
inline ::traindata* MapTrainData::release_traindata() {
  clear_has_traindata();
  ::traindata* temp = traindata_;
  traindata_ = NULL;
  return temp;
}
inline void MapTrainData::set_allocated_traindata(::traindata* traindata) {
  delete traindata_;
  traindata_ = traindata;
  if (traindata) {
    set_has_traindata();
  } else {
    clear_has_traindata();
  }
  // @@protoc_insertion_point(field_set_allocated:MapTrainData.traindata)
}

// -------------------------------------------------------------------

// GetFleetCommand

// required string ipaddress = 1;
inline bool GetFleetCommand::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetFleetCommand::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetFleetCommand::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetFleetCommand::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& GetFleetCommand::ipaddress() const {
  // @@protoc_insertion_point(field_get:GetFleetCommand.ipaddress)
  return *ipaddress_;
}
inline void GetFleetCommand::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
  // @@protoc_insertion_point(field_set:GetFleetCommand.ipaddress)
}
inline void GetFleetCommand::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:GetFleetCommand.ipaddress)
}
inline void GetFleetCommand::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetFleetCommand.ipaddress)
}
inline ::std::string* GetFleetCommand::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GetFleetCommand.ipaddress)
  return ipaddress_;
}
inline ::std::string* GetFleetCommand::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetFleetCommand::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GetFleetCommand.ipaddress)
}

// -------------------------------------------------------------------

// GetFleetResponse

// repeated .MapTrainData traindata = 1;
inline int GetFleetResponse::traindata_size() const {
  return traindata_.size();
}
inline void GetFleetResponse::clear_traindata() {
  traindata_.Clear();
}
inline const ::MapTrainData& GetFleetResponse::traindata(int index) const {
  // @@protoc_insertion_point(field_get:GetFleetResponse.traindata)
  return traindata_.Get(index);
}
inline ::MapTrainData* GetFleetResponse::mutable_traindata(int index) {
  // @@protoc_insertion_point(field_mutable:GetFleetResponse.traindata)
  return traindata_.Mutable(index);
}
inline ::MapTrainData* GetFleetResponse::add_traindata() {
  // @@protoc_insertion_point(field_add:GetFleetResponse.traindata)
  return traindata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapTrainData >&
GetFleetResponse::traindata() const {
  // @@protoc_insertion_point(field_list:GetFleetResponse.traindata)
  return traindata_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapTrainData >*
GetFleetResponse::mutable_traindata() {
  // @@protoc_insertion_point(field_mutable_list:GetFleetResponse.traindata)
  return &traindata_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_RCFProtoServices_2eproto__INCLUDED
